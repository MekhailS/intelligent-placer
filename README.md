# Intelligent Placer

## Постановка задачи
### Общее описание
Необходимо по поданной на вход фотографии одного или нескольких расположенных на листе бумаги предметов на фоне горизонтальной поверхности, и заданном на другом листе бумаги многоугольнику, определить, можно ли расположить одновременно все эти предметы на плоскости так, чтобы они влезли в этот многоугольник. Предметы и горизонтальная поверхность (фон), которые могут оказаться на фотографии, заранее известны

### Ввод \ вывод
Ввод: картинка предметов с многоугольником в формате .png без сжатия

Вывод: ответ "yes" \ "no" в текстовый файл answer_<имя поданой картинки на вход>.txt

## Требования
### Общие к фотографиям
- Многоугольник задавается фигурой, нарисованной красным маркером на белом листе бумаги, сфотографированной вместе с предметами
- Толщина нарисованной линии не превышает 5мм
- Фотографии сделаны с камеры расположенной перпендекулярно к поверхности, на высоте 35 сантиметров, при одинаковом освещении
- Предметы и поверхность должны быть равномерно и хорошо освещены - отсутствие пересвеченных и серо-черных областей
- На фотографии нет лишних предметов, кроме тех, которые заранее были известны
### К поверхности
- Горизонатльная (без выпуклостей и впадин)
- Однородная (без сильно выделяющихся объектов: узоров, пятен)
- Одна для всех фотографий
- Предметы распологаются на одном белом чистом листе бумаги
- Многоугольник нарисован на отдельном чистом белом листе бумаги, Лист бумаги с многоугольником всегда расположен слева от листа бумаги с предметами
- Листы с предметами и нарисованым многоугольником не пересекаются и не имеют общих границ
### К предметам на поверхности
- Предметы видны на листе бумаге
- Предметы не перекрывают друг друга
- Предметы не выходят на фон (т.е. предмет может не быть виден целиком на фотографии, но не может выходить на фон)
- Не имеют общих границ (т.е. предметы не могут лежать "впритык" к друг другу)

## Датасет
[Примеры](https://github.com/MekhailS/intelligent-placer/tree/dev/examples)


## Результаты

Можно посмотреть результаты работы алгоритма в папках [examples/fit_predicted](examples/fit_predicted) и [examples/not_fit_predicted](examples/not_fit_predicted)

Имя файла соответствует инпут файлу (так же из папки examples) с префиксом, отвечающим на вопрос "удалось ли уложить объекты в контур"   
Само изображение содержит итоговую успешную укладку: т.е. если SUCCESS, то таким образом алгоритм уложил объекты в контур, если FAILED, то алгоритму не удалось уложить объекты в контур, и на картинке изображена укладка без всех объектов

## Описание алгоритма

### 1. Отделение листов от друг друга (получение бинарных масок листов)

1. Конвертация в ч/б
2. Сглаживаем шум медианным фильтром (7x7)
3. Методом Оцу бинаризуем изображение
4. Эвристический постпроцессинг: отделяем объекты, заходящие за пределы листа от фона (чтобы их алгоритм не считал за фон)
5. Убираем шум морфологическими операциями
6. Выбираем внешние контуры: два листа, получаем их бинарные маски

### 2. Обработка левого листа (содержащего контур, в который требуется уложить объекты)

1. Конвертация в ч/б
2. Сглаживаем шум медианным фильтром (7x7)
3. Методом Оцу бинаризуем изображение
4. Накладываем маску левого листа (чуть увеличенную через морф. операции, чтобы края листа не мешали)
5. Морфологическими операциями расширяем найденные маски (т.к. контур может быть нарисован прерывисто :c)
6. Выбираем внешний контур с самой максимальной площадью
7. Получаем маску для контура, в который будем укладывать объекты

### 3. Обработка правого листа (содержащего контур, в который требуется уложить объекты)

1. Конвертация в ч/б
2. Сглаживаем шум медианным фильтром (7x7)
3. - Находим маску с помощью метода Оцу
   - Находим маску краев объектов с помощью оператора Лапласа (Оцу не все объекты успешно находит, напр. белые объекты, с ними метод, основанный на операторе Лапласа работает лучше)
   - Объединяем маски, полученные выше

4. Таким образом получаем примерные маски для объектов
5. "Вырезаем" области 256x256, содержащие объекты
6. Получили изображения 256х256, содержащие отдельные объекты
7. С помощью нейросети классифицируем вырезанные фотографии объектов (класс – тип объекта, их всего 10)
8. Таким образом получаем точные контуры объектов с правого листа

#### Нейросеть

Нейросеть обучаем на основе данных из папки data, объекты выделяем таким же образом, как и в п. 3-4 выше

Архитектура – самая быстрая и легковесная, SqueezeNet 1.1  
Процесс обучения можно посмотреть в [ноутбуке](/stage_three_train_nn_place_bricks/train_model.ipynb)

Полученная точность: 96%
Нейросеть обучаем на основе данных из папки data, объекты выделяем таким же образом, как и в п. 3-4 выше


### 4. Укладка объектов в зону

1. Итого к текущему моменту у нас имеется маска зоны, в которую требуется уложить объекты справа, и точные маски объектов справа
2. Строим сетку NxN позиций (пикселей), покрывающую bounding box зоны, в которую требуется уложить объекты
3. Отсортируем объекты по их площади
4. Последовательно будем пытаться "уложить" объект в каждую позицию из сетки, построенной раньше:
   - Позиция на сетке должна соответствовать не занятому пикселю зоны
   - Центр укладываемого объекта - текущая позиция на сетке
   - Будем рассматривать повороты объекта (18 углов от 0 до 360) 
5. Таким образом, мы укладываем объекты "попытками" уложить объект на текущую позицию с возможностью вращения
6. Если удалось таким образом уложить все объекты – возвращаем True, иначе False